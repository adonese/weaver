// Code generated by "weaver generate". DO NOT EDIT.
//go:build !ignoreWeaverGen

package main

import (
	"context"
	"errors"
	"fmt"
	"github.com/ServiceWeaver/weaver"
	"github.com/ServiceWeaver/weaver/runtime/codegen"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
	"reflect"
	"time"
)

func init() {
	codegen.Register(codegen.Registration{
		Name:  "github.com/adonese/exinity/GatewayA",
		Iface: reflect.TypeOf((*GatewayA)(nil)).Elem(),
		Impl:  reflect.TypeOf(gatewayA{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return gatewayA_local_stub{impl: impl.(GatewayA), tracer: tracer, processDepositMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/GatewayA", Method: "ProcessDeposit", Remote: false, Generated: true}), processWithdrawalMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/GatewayA", Method: "ProcessWithdrawal", Remote: false, Generated: true})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return gatewayA_client_stub{stub: stub, processDepositMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/GatewayA", Method: "ProcessDeposit", Remote: true, Generated: true}), processWithdrawalMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/GatewayA", Method: "ProcessWithdrawal", Remote: true, Generated: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return gatewayA_server_stub{impl: impl.(GatewayA), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return gatewayA_reflect_stub{caller: caller}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:  "github.com/adonese/exinity/GatewayB",
		Iface: reflect.TypeOf((*GatewayB)(nil)).Elem(),
		Impl:  reflect.TypeOf(gatewayB{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return gatewayB_local_stub{impl: impl.(GatewayB), tracer: tracer, processDepositMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/GatewayB", Method: "ProcessDeposit", Remote: false, Generated: true}), processWithdrawalMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/GatewayB", Method: "ProcessWithdrawal", Remote: false, Generated: true})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return gatewayB_client_stub{stub: stub, processDepositMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/GatewayB", Method: "ProcessDeposit", Remote: true, Generated: true}), processWithdrawalMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/GatewayB", Method: "ProcessWithdrawal", Remote: true, Generated: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return gatewayB_server_stub{impl: impl.(GatewayB), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return gatewayB_reflect_stub{caller: caller}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:  "github.com/adonese/exinity/GatewayRouter",
		Iface: reflect.TypeOf((*GatewayRouter)(nil)).Elem(),
		Impl:  reflect.TypeOf(gatewayRouter{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return gatewayRouter_local_stub{impl: impl.(GatewayRouter), tracer: tracer, routePaymentMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/GatewayRouter", Method: "RoutePayment", Remote: false, Generated: true})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return gatewayRouter_client_stub{stub: stub, routePaymentMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/GatewayRouter", Method: "RoutePayment", Remote: true, Generated: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return gatewayRouter_server_stub{impl: impl.(GatewayRouter), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return gatewayRouter_reflect_stub{caller: caller}
		},
		RefData: "⟦0cae84df:wEaVeReDgE:github.com/adonese/exinity/GatewayRouter→github.com/adonese/exinity/GatewayA⟧\n⟦a8003876:wEaVeReDgE:github.com/adonese/exinity/GatewayRouter→github.com/adonese/exinity/GatewayB⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:      "github.com/ServiceWeaver/weaver/Main",
		Iface:     reflect.TypeOf((*weaver.Main)(nil)).Elem(),
		Impl:      reflect.TypeOf(app{}),
		Listeners: []string{"lis"},
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return main_local_stub{impl: impl.(weaver.Main), tracer: tracer}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any { return main_client_stub{stub: stub} },
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return main_server_stub{impl: impl.(weaver.Main), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return main_reflect_stub{caller: caller}
		},
		RefData: "⟦fc0a6d77:wEaVeReDgE:github.com/ServiceWeaver/weaver/Main→github.com/adonese/exinity/PaymentService⟧\n⟦7fe6c923:wEaVeReDgE:github.com/ServiceWeaver/weaver/Main→github.com/adonese/exinity/GatewayA⟧\n⟦4e0163dc:wEaVeReDgE:github.com/ServiceWeaver/weaver/Main→github.com/adonese/exinity/GatewayB⟧\n⟦6fe9033b:wEaVeReDgE:github.com/ServiceWeaver/weaver/Main→github.com/adonese/exinity/GatewayRouter⟧\n⟦26b6f94a:wEaVeReDgE:github.com/ServiceWeaver/weaver/Main→github.com/adonese/exinity/Merger⟧\n⟦d535aefb:wEaVeRlIsTeNeRs:github.com/ServiceWeaver/weaver/Main→lis⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:  "github.com/adonese/exinity/Merger",
		Iface: reflect.TypeOf((*Merger)(nil)).Elem(),
		Impl:  reflect.TypeOf(merger{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return merger_local_stub{impl: impl.(Merger), tracer: tracer, mergeMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/Merger", Method: "Merge", Remote: false, Generated: true})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return merger_client_stub{stub: stub, mergeMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/Merger", Method: "Merge", Remote: true, Generated: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return merger_server_stub{impl: impl.(Merger), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return merger_reflect_stub{caller: caller}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:  "github.com/adonese/exinity/PaymentService",
		Iface: reflect.TypeOf((*PaymentService)(nil)).Elem(),
		Impl:  reflect.TypeOf(paymentService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return paymentService_local_stub{impl: impl.(PaymentService), tracer: tracer, getTransactionMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/PaymentService", Method: "GetTransaction", Remote: false, Generated: true}), handleCallbackMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/PaymentService", Method: "HandleCallback", Remote: false, Generated: true}), processPaymentMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/PaymentService", Method: "ProcessPayment", Remote: false, Generated: true})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return paymentService_client_stub{stub: stub, getTransactionMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/PaymentService", Method: "GetTransaction", Remote: true, Generated: true}), handleCallbackMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/PaymentService", Method: "HandleCallback", Remote: true, Generated: true}), processPaymentMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/adonese/exinity/PaymentService", Method: "ProcessPayment", Remote: true, Generated: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return paymentService_server_stub{impl: impl.(PaymentService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return paymentService_reflect_stub{caller: caller}
		},
		RefData: "⟦b351b998:wEaVeReDgE:github.com/adonese/exinity/PaymentService→github.com/adonese/exinity/GatewayRouter⟧\n",
	})
}

// weaver.InstanceOf checks.
var _ weaver.InstanceOf[GatewayA] = (*gatewayA)(nil)
var _ weaver.InstanceOf[GatewayB] = (*gatewayB)(nil)
var _ weaver.InstanceOf[GatewayRouter] = (*gatewayRouter)(nil)
var _ weaver.InstanceOf[weaver.Main] = (*app)(nil)
var _ weaver.InstanceOf[Merger] = (*merger)(nil)
var _ weaver.InstanceOf[PaymentService] = (*paymentService)(nil)

// weaver.Router checks.
var _ weaver.Unrouted = (*gatewayA)(nil)
var _ weaver.Unrouted = (*gatewayB)(nil)
var _ weaver.Unrouted = (*gatewayRouter)(nil)
var _ weaver.Unrouted = (*app)(nil)
var _ weaver.Unrouted = (*merger)(nil)
var _ weaver.Unrouted = (*paymentService)(nil)

// Local stub implementations.

type gatewayA_local_stub struct {
	impl                     GatewayA
	tracer                   trace.Tracer
	processDepositMetrics    *codegen.MethodMetrics
	processWithdrawalMetrics *codegen.MethodMetrics
}

// Check that gatewayA_local_stub implements the GatewayA interface.
var _ GatewayA = (*gatewayA_local_stub)(nil)

func (s gatewayA_local_stub) ProcessDeposit(ctx context.Context, a0 float64) (r0 string, err error) {
	// Update metrics.
	begin := s.processDepositMetrics.Begin()
	defer func() { s.processDepositMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.GatewayA.ProcessDeposit", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ProcessDeposit(ctx, a0)
}

func (s gatewayA_local_stub) ProcessWithdrawal(ctx context.Context, a0 float64) (r0 string, err error) {
	// Update metrics.
	begin := s.processWithdrawalMetrics.Begin()
	defer func() { s.processWithdrawalMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.GatewayA.ProcessWithdrawal", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ProcessWithdrawal(ctx, a0)
}

type gatewayB_local_stub struct {
	impl                     GatewayB
	tracer                   trace.Tracer
	processDepositMetrics    *codegen.MethodMetrics
	processWithdrawalMetrics *codegen.MethodMetrics
}

// Check that gatewayB_local_stub implements the GatewayB interface.
var _ GatewayB = (*gatewayB_local_stub)(nil)

func (s gatewayB_local_stub) ProcessDeposit(ctx context.Context, a0 float64) (r0 string, err error) {
	// Update metrics.
	begin := s.processDepositMetrics.Begin()
	defer func() { s.processDepositMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.GatewayB.ProcessDeposit", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ProcessDeposit(ctx, a0)
}

func (s gatewayB_local_stub) ProcessWithdrawal(ctx context.Context, a0 float64) (r0 string, err error) {
	// Update metrics.
	begin := s.processWithdrawalMetrics.Begin()
	defer func() { s.processWithdrawalMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.GatewayB.ProcessWithdrawal", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ProcessWithdrawal(ctx, a0)
}

type gatewayRouter_local_stub struct {
	impl                GatewayRouter
	tracer              trace.Tracer
	routePaymentMetrics *codegen.MethodMetrics
}

// Check that gatewayRouter_local_stub implements the GatewayRouter interface.
var _ GatewayRouter = (*gatewayRouter_local_stub)(nil)

func (s gatewayRouter_local_stub) RoutePayment(ctx context.Context, a0 float64, a1 string, a2 string) (r0 string, err error) {
	// Update metrics.
	begin := s.routePaymentMetrics.Begin()
	defer func() { s.routePaymentMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.GatewayRouter.RoutePayment", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.RoutePayment(ctx, a0, a1, a2)
}

type main_local_stub struct {
	impl   weaver.Main
	tracer trace.Tracer
}

// Check that main_local_stub implements the weaver.Main interface.
var _ weaver.Main = (*main_local_stub)(nil)

type merger_local_stub struct {
	impl         Merger
	tracer       trace.Tracer
	mergeMetrics *codegen.MethodMetrics
}

// Check that merger_local_stub implements the Merger interface.
var _ Merger = (*merger_local_stub)(nil)

func (s merger_local_stub) Merge(ctx context.Context, a0 Transaction) (r0 Response, err error) {
	// Update metrics.
	begin := s.mergeMetrics.Begin()
	defer func() { s.mergeMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.Merger.Merge", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Merge(ctx, a0)
}

type paymentService_local_stub struct {
	impl                  PaymentService
	tracer                trace.Tracer
	getTransactionMetrics *codegen.MethodMetrics
	handleCallbackMetrics *codegen.MethodMetrics
	processPaymentMetrics *codegen.MethodMetrics
}

// Check that paymentService_local_stub implements the PaymentService interface.
var _ PaymentService = (*paymentService_local_stub)(nil)

func (s paymentService_local_stub) GetTransaction(ctx context.Context, a0 string) (r0 *Transaction, err error) {
	// Update metrics.
	begin := s.getTransactionMetrics.Begin()
	defer func() { s.getTransactionMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.PaymentService.GetTransaction", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetTransaction(ctx, a0)
}

func (s paymentService_local_stub) HandleCallback(ctx context.Context, a0 string, a1 []byte) (err error) {
	// Update metrics.
	begin := s.handleCallbackMetrics.Begin()
	defer func() { s.handleCallbackMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.PaymentService.HandleCallback", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.HandleCallback(ctx, a0, a1)
}

func (s paymentService_local_stub) ProcessPayment(ctx context.Context, a0 float64, a1 string, a2 string) (r0 *Transaction, err error) {
	// Update metrics.
	begin := s.processPaymentMetrics.Begin()
	defer func() { s.processPaymentMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.PaymentService.ProcessPayment", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ProcessPayment(ctx, a0, a1, a2)
}

// Client stub implementations.

type gatewayA_client_stub struct {
	stub                     codegen.Stub
	processDepositMetrics    *codegen.MethodMetrics
	processWithdrawalMetrics *codegen.MethodMetrics
}

// Check that gatewayA_client_stub implements the GatewayA interface.
var _ GatewayA = (*gatewayA_client_stub)(nil)

func (s gatewayA_client_stub) ProcessDeposit(ctx context.Context, a0 float64) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.processDepositMetrics.Begin()
	defer func() { s.processDepositMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.GatewayA.ProcessDeposit", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Float64(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s gatewayA_client_stub) ProcessWithdrawal(ctx context.Context, a0 float64) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.processWithdrawalMetrics.Begin()
	defer func() { s.processWithdrawalMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.GatewayA.ProcessWithdrawal", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Float64(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

type gatewayB_client_stub struct {
	stub                     codegen.Stub
	processDepositMetrics    *codegen.MethodMetrics
	processWithdrawalMetrics *codegen.MethodMetrics
}

// Check that gatewayB_client_stub implements the GatewayB interface.
var _ GatewayB = (*gatewayB_client_stub)(nil)

func (s gatewayB_client_stub) ProcessDeposit(ctx context.Context, a0 float64) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.processDepositMetrics.Begin()
	defer func() { s.processDepositMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.GatewayB.ProcessDeposit", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Float64(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s gatewayB_client_stub) ProcessWithdrawal(ctx context.Context, a0 float64) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.processWithdrawalMetrics.Begin()
	defer func() { s.processWithdrawalMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.GatewayB.ProcessWithdrawal", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Float64(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

type gatewayRouter_client_stub struct {
	stub                codegen.Stub
	routePaymentMetrics *codegen.MethodMetrics
}

// Check that gatewayRouter_client_stub implements the GatewayRouter interface.
var _ GatewayRouter = (*gatewayRouter_client_stub)(nil)

func (s gatewayRouter_client_stub) RoutePayment(ctx context.Context, a0 float64, a1 string, a2 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.routePaymentMetrics.Begin()
	defer func() { s.routePaymentMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.GatewayRouter.RoutePayment", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += (4 + len(a1))
	size += (4 + len(a2))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Float64(a0)
	enc.String(a1)
	enc.String(a2)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

type main_client_stub struct {
	stub codegen.Stub
}

// Check that main_client_stub implements the weaver.Main interface.
var _ weaver.Main = (*main_client_stub)(nil)

type merger_client_stub struct {
	stub         codegen.Stub
	mergeMetrics *codegen.MethodMetrics
}

// Check that merger_client_stub implements the Merger interface.
var _ Merger = (*merger_client_stub)(nil)

func (s merger_client_stub) Merge(ctx context.Context, a0 Transaction) (r0 Response, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.mergeMetrics.Begin()
	defer func() { s.mergeMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.Merger.Merge", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type paymentService_client_stub struct {
	stub                  codegen.Stub
	getTransactionMetrics *codegen.MethodMetrics
	handleCallbackMetrics *codegen.MethodMetrics
	processPaymentMetrics *codegen.MethodMetrics
}

// Check that paymentService_client_stub implements the PaymentService interface.
var _ PaymentService = (*paymentService_client_stub)(nil)

func (s paymentService_client_stub) GetTransaction(ctx context.Context, a0 string) (r0 *Transaction, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getTransactionMetrics.Begin()
	defer func() { s.getTransactionMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.PaymentService.GetTransaction", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_ptr_Transaction_6e3f1442(dec)
	err = dec.Error()
	return
}

func (s paymentService_client_stub) HandleCallback(ctx context.Context, a0 string, a1 []byte) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.handleCallbackMetrics.Begin()
	defer func() { s.handleCallbackMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.PaymentService.HandleCallback", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + (len(a1) * 1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	serviceweaver_enc_slice_byte_87461245(enc, a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s paymentService_client_stub) ProcessPayment(ctx context.Context, a0 float64, a1 string, a2 string) (r0 *Transaction, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.processPaymentMetrics.Begin()
	defer func() { s.processPaymentMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.PaymentService.ProcessPayment", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += (4 + len(a1))
	size += (4 + len(a2))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Float64(a0)
	enc.String(a1)
	enc.String(a2)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_ptr_Transaction_6e3f1442(dec)
	err = dec.Error()
	return
}

// Note that "weaver generate" will always generate the error message below.
// Everything is okay. The error message is only relevant if you see it when
// you run "go build" or "go run".
var _ codegen.LatestVersion = codegen.Version[[0][24]struct{}](`

ERROR: You generated this file with 'weaver generate' v0.24.3 (codegen
version v0.24.0). The generated code is incompatible with the version of the
github.com/ServiceWeaver/weaver module that you're using. The weaver module
version can be found in your go.mod file or by running the following command.

    go list -m github.com/ServiceWeaver/weaver

We recommend updating the weaver module and the 'weaver generate' command by
running the following.

    go get github.com/ServiceWeaver/weaver@latest
    go install github.com/ServiceWeaver/weaver/cmd/weaver@latest

Then, re-run 'weaver generate' and re-build your code. If the problem persists,
please file an issue at https://github.com/ServiceWeaver/weaver/issues.

`)

// Server stub implementations.

type gatewayA_server_stub struct {
	impl    GatewayA
	addLoad func(key uint64, load float64)
}

// Check that gatewayA_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*gatewayA_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s gatewayA_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "ProcessDeposit":
		return s.processDeposit
	case "ProcessWithdrawal":
		return s.processWithdrawal
	default:
		return nil
	}
}

func (s gatewayA_server_stub) processDeposit(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 float64
	a0 = dec.Float64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ProcessDeposit(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s gatewayA_server_stub) processWithdrawal(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 float64
	a0 = dec.Float64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ProcessWithdrawal(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

type gatewayB_server_stub struct {
	impl    GatewayB
	addLoad func(key uint64, load float64)
}

// Check that gatewayB_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*gatewayB_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s gatewayB_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "ProcessDeposit":
		return s.processDeposit
	case "ProcessWithdrawal":
		return s.processWithdrawal
	default:
		return nil
	}
}

func (s gatewayB_server_stub) processDeposit(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 float64
	a0 = dec.Float64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ProcessDeposit(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s gatewayB_server_stub) processWithdrawal(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 float64
	a0 = dec.Float64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ProcessWithdrawal(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

type gatewayRouter_server_stub struct {
	impl    GatewayRouter
	addLoad func(key uint64, load float64)
}

// Check that gatewayRouter_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*gatewayRouter_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s gatewayRouter_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "RoutePayment":
		return s.routePayment
	default:
		return nil
	}
}

func (s gatewayRouter_server_stub) routePayment(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 float64
	a0 = dec.Float64()
	var a1 string
	a1 = dec.String()
	var a2 string
	a2 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.RoutePayment(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

type main_server_stub struct {
	impl    weaver.Main
	addLoad func(key uint64, load float64)
}

// Check that main_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*main_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s main_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	default:
		return nil
	}
}

type merger_server_stub struct {
	impl    Merger
	addLoad func(key uint64, load float64)
}

// Check that merger_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*merger_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s merger_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "Merge":
		return s.merge
	default:
		return nil
	}
}

func (s merger_server_stub) merge(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 Transaction
	(&a0).WeaverUnmarshal(dec)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.Merge(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type paymentService_server_stub struct {
	impl    PaymentService
	addLoad func(key uint64, load float64)
}

// Check that paymentService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*paymentService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s paymentService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "GetTransaction":
		return s.getTransaction
	case "HandleCallback":
		return s.handleCallback
	case "ProcessPayment":
		return s.processPayment
	default:
		return nil
	}
}

func (s paymentService_server_stub) getTransaction(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetTransaction(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_ptr_Transaction_6e3f1442(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s paymentService_server_stub) handleCallback(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 []byte
	a1 = serviceweaver_dec_slice_byte_87461245(dec)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.HandleCallback(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s paymentService_server_stub) processPayment(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 float64
	a0 = dec.Float64()
	var a1 string
	a1 = dec.String()
	var a2 string
	a2 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ProcessPayment(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_ptr_Transaction_6e3f1442(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

// Reflect stub implementations.

type gatewayA_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that gatewayA_reflect_stub implements the GatewayA interface.
var _ GatewayA = (*gatewayA_reflect_stub)(nil)

func (s gatewayA_reflect_stub) ProcessDeposit(ctx context.Context, a0 float64) (r0 string, err error) {
	err = s.caller("ProcessDeposit", ctx, []any{a0}, []any{&r0})
	return
}

func (s gatewayA_reflect_stub) ProcessWithdrawal(ctx context.Context, a0 float64) (r0 string, err error) {
	err = s.caller("ProcessWithdrawal", ctx, []any{a0}, []any{&r0})
	return
}

type gatewayB_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that gatewayB_reflect_stub implements the GatewayB interface.
var _ GatewayB = (*gatewayB_reflect_stub)(nil)

func (s gatewayB_reflect_stub) ProcessDeposit(ctx context.Context, a0 float64) (r0 string, err error) {
	err = s.caller("ProcessDeposit", ctx, []any{a0}, []any{&r0})
	return
}

func (s gatewayB_reflect_stub) ProcessWithdrawal(ctx context.Context, a0 float64) (r0 string, err error) {
	err = s.caller("ProcessWithdrawal", ctx, []any{a0}, []any{&r0})
	return
}

type gatewayRouter_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that gatewayRouter_reflect_stub implements the GatewayRouter interface.
var _ GatewayRouter = (*gatewayRouter_reflect_stub)(nil)

func (s gatewayRouter_reflect_stub) RoutePayment(ctx context.Context, a0 float64, a1 string, a2 string) (r0 string, err error) {
	err = s.caller("RoutePayment", ctx, []any{a0, a1, a2}, []any{&r0})
	return
}

type main_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that main_reflect_stub implements the weaver.Main interface.
var _ weaver.Main = (*main_reflect_stub)(nil)

type merger_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that merger_reflect_stub implements the Merger interface.
var _ Merger = (*merger_reflect_stub)(nil)

func (s merger_reflect_stub) Merge(ctx context.Context, a0 Transaction) (r0 Response, err error) {
	err = s.caller("Merge", ctx, []any{a0}, []any{&r0})
	return
}

type paymentService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that paymentService_reflect_stub implements the PaymentService interface.
var _ PaymentService = (*paymentService_reflect_stub)(nil)

func (s paymentService_reflect_stub) GetTransaction(ctx context.Context, a0 string) (r0 *Transaction, err error) {
	err = s.caller("GetTransaction", ctx, []any{a0}, []any{&r0})
	return
}

func (s paymentService_reflect_stub) HandleCallback(ctx context.Context, a0 string, a1 []byte) (err error) {
	err = s.caller("HandleCallback", ctx, []any{a0, a1}, []any{})
	return
}

func (s paymentService_reflect_stub) ProcessPayment(ctx context.Context, a0 float64, a1 string, a2 string) (r0 *Transaction, err error) {
	err = s.caller("ProcessPayment", ctx, []any{a0, a1, a2}, []any{&r0})
	return
}

// AutoMarshal implementations.

var _ codegen.AutoMarshal = (*ErrorResponse)(nil)

type __is_ErrorResponse[T ~struct {
	weaver.AutoMarshal
	Message string
	Code    string
}] struct{}

var _ __is_ErrorResponse[ErrorResponse]

func (x *ErrorResponse) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("ErrorResponse.WeaverMarshal: nil receiver"))
	}
	enc.String(x.Message)
	enc.String(x.Code)
}

func (x *ErrorResponse) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("ErrorResponse.WeaverUnmarshal: nil receiver"))
	}
	x.Message = dec.String()
	x.Code = dec.String()
}

var _ codegen.AutoMarshal = (*Response)(nil)

type __is_Response[T ~struct {
	weaver.AutoMarshal
	Transaction
	XMLResponse string
}] struct{}

var _ __is_Response[Response]

func (x *Response) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("Response.WeaverMarshal: nil receiver"))
	}
	(x.Transaction).WeaverMarshal(enc)
	enc.String(x.XMLResponse)
}

func (x *Response) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("Response.WeaverUnmarshal: nil receiver"))
	}
	(&x.Transaction).WeaverUnmarshal(dec)
	x.XMLResponse = dec.String()
}

var _ codegen.AutoMarshal = (*Transaction)(nil)

type __is_Transaction[T ~struct {
	weaver.AutoMarshal
	ID        string
	Amount    float64
	Type      string
	Status    string
	Gateway   string
	CreatedAt time.Time
	UpdatedAt time.Time
}] struct{}

var _ __is_Transaction[Transaction]

func (x *Transaction) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("Transaction.WeaverMarshal: nil receiver"))
	}
	enc.String(x.ID)
	enc.Float64(x.Amount)
	enc.String(x.Type)
	enc.String(x.Status)
	enc.String(x.Gateway)
	enc.EncodeBinaryMarshaler(&x.CreatedAt)
	enc.EncodeBinaryMarshaler(&x.UpdatedAt)
}

func (x *Transaction) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("Transaction.WeaverUnmarshal: nil receiver"))
	}
	x.ID = dec.String()
	x.Amount = dec.Float64()
	x.Type = dec.String()
	x.Status = dec.String()
	x.Gateway = dec.String()
	dec.DecodeBinaryUnmarshaler(&x.CreatedAt)
	dec.DecodeBinaryUnmarshaler(&x.UpdatedAt)
}

// Encoding/decoding implementations.

func serviceweaver_enc_ptr_Transaction_6e3f1442(enc *codegen.Encoder, arg *Transaction) {
	if arg == nil {
		enc.Bool(false)
	} else {
		enc.Bool(true)
		(*arg).WeaverMarshal(enc)
	}
}

func serviceweaver_dec_ptr_Transaction_6e3f1442(dec *codegen.Decoder) *Transaction {
	if !dec.Bool() {
		return nil
	}
	var res Transaction
	(&res).WeaverUnmarshal(dec)
	return &res
}

func serviceweaver_enc_slice_byte_87461245(enc *codegen.Encoder, arg []byte) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for i := 0; i < len(arg); i++ {
		enc.Byte(arg[i])
	}
}

func serviceweaver_dec_slice_byte_87461245(dec *codegen.Decoder) []byte {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make([]byte, n)
	for i := 0; i < n; i++ {
		res[i] = dec.Byte()
	}
	return res
}
